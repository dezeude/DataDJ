<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Three.js CSV Scatterplot 3D + MIDI</title>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "d3-dsv": "https://cdn.jsdelivr.net/npm/d3-dsv@3/+esm",
        "controls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from "three";
        import { csvParse } from "d3-dsv";
        import { OrbitControls } from "controls";
        import * as midi from "./midi.js";

        midi.getPermission();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        let camera, points, material, controls;

        // Perspective camera for 3D
        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            5000
        );
        camera.position.set(0, 0, 200);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Load CSV
        fetch("data.csv")
            .then((res) => res.text())
            .then((text) => {
                const data = csvParse(text);

                const numPoints = data.length;
                const positions = new Float32Array(numPoints * 3);

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;

                data.forEach((row, i) => {
                    const x = parseFloat(row.x);
                    const y = parseFloat(row.y);
                    const z = parseFloat(row.z);

                    positions.set([x, y, z], i * 3);

                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                });


                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

                material = new THREE.PointsMaterial({
                    size: 2,
                    color: 0xff5533
                });

                points = new THREE.Points(geometry, material);
                scene.add(points);

                // Center camera on dataset
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                const midZ = (minZ + maxZ) / 2;
                controls.target.set(midX, midY, midZ);
                controls.update();

                animate();
            });

        // Hook up MIDI to change material size (as an example)
        navigator.requestMIDIAccess().then((midiAccess) => {
            midi.listInputsAndOutputs(midiAccess);
            let sizeStep = 0.5;

            midi.startLoggingMIDIInput(midiAccess, (event) => {
                if (!material) return;
                if (event.data[0] === 0xb0 && event.data[1] == 0x14) {
                    if (event.data[2] === 0x41) {
                        material.size += sizeStep;
                    } else if (event.data[2] === 0x1) {
                        material.size = Math.max(0.1, material.size - sizeStep);
                    }
                }
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener("resize", () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>